<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Grafos â€“ CC72N Estructuras de Datos Comprimidas</title>

		<meta name="description" content="Estructuras Comprimidas: Grafos">
		<meta name="author" content="Francisco Montoto">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

        <style type="text/css">
            .node {
                border-radius: 6px;
                width: 12px;
                height: 12px;
                margin: -6px 0 0 -6px;
                position: absolute;
            }

            .link {
                position: absolute;
                border-bottom: solid #DC0F0F 1px;
                height: 0;
                stroke: white;
                -webkit-transform-origin: 0 0;
                -moz-transform-origin: 0 0;
                -ms-transform-origin: 0 0;
                -o-transform-origin: 0 0;
                transform-origin: 0 0;
            }
        </style>


		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Grafos 2.0</h1>
					<p>
						<small>Francisco Montoto</small>
					</p>
				</section>

				<section>
					<h2>Grafos Etiquetados</h2>
                    <ul style="text-align:left;">
                        <li class="fragment">A diferencia de los grafos vistos en la sesi&oacute;n anterior, en un grafo etiquetado las aristas son tripletes $(u, v, l)$ donde diremos que $l$ es su etiqueta. Por simplicidad las etiquetas pertenecen al diccionario $[1, \lambda]$</li>

                        <li class="fragment">Para mantener las mismas operaciones en este nuevo tipo de grafo bastar&iacute;a agregar un arreglo $L[1,e]$ donde $L[i]$ contenga la etiqueta de la arista correspondiente a $N[i]$.</li>
                        <li class="fragment">Sin embargo, queremos realizar nuevas operaciones para este tipo de grafos.</li>
                    </ul>
				</section>

                <section>
                    <h2>Operaciones Sobre Grafos Etiquetados</h2>
                    <p style="text-align: left;" class="fragment">
                        Sea $E_l = \lbrace (v, u), (v, u, l) \in E \rbrace$, definimos entonces $G_l$ como $(V, E_l)$
                    </p>
                    <p style="text-align: left;" class="fragment">
                        Las operaciones que deseamos efectuar entonces las nombramos como $adj_l$, $neigh_l$, $rneigh_l$, $outdegree_l$ e $indegree_l$. Poseer&aacute;n la misma sem&aacute;ntica que las anteriores operaciones, pero se aplicaran sobre $G_l$
                    </p>

				</section>
                <section>
                    <h2>Nuevas estructuras</h2>
                    <p style="text-align: left;" class="fragment">
                        Agregamos $L[1, e]$
                    </p>
                    <p style="text-align: left;" class="fragment">
                        Agregamos $B_L$
                    </p>
                    <p style="text-align: left;" class="fragment">
                        Reemplazamos $N$ por $N_\lambda$
                    </p>
                </section>
                <section>
                    <h2>Operaciones</h2>
                    <h4 class="fragment" style="text-align:left;">Se mantienen</h4>
                    <p class="fragment" style="text-align:left;">
                        $outdegree(G, v): select(B, v + 1) - select(B, v) -1$
                    </p>
                    <p class="fragment" style="text-align:left;">
                        $indegree(G, v) = rank_v(N, e)$
                    </p>
                </section>
                <section>
                    <h2>Operaciones</h2>
                    <h4 class="fragment" style="text-align:left;">Requieren modificaci&oacute;n</h4>

                    <p class="fragment" style="text-align:left;">
                        $neigh(G, v)[j]$ <span class="fragment highlight-red">$= access(N, select(B, v) - v + j)$</span><br>
                    </p>
                    <p class="fragment">
                        $\Rightarrow N[select(B_L, l) - l + rank_l(L, p)]$
                    </p>
                    <p class="fragment" style="text-align:left;">
                        $rneigh(G, v)[j]$ = <span class="fragment highlight-red">$select_0(B, select_v(N, j)) - select_v(N, j)$</span>
                    </p>
                    <p class="fragment">
                        $\Rightarrow N[select_0(B, s) - s]$
                    </p>
                    <p class="fragment" style="text-align:left;">
                        $adj(G, v, u)$ <span class="fragment highlight-red">$ssi$ $rank_u(N, select(B, v + 1) - (v + 1)) - rank_u(N, select(B, v) - v) = 1$</span>
                    </p>
                    <p class="fragment">
                        $\Rightarrow \bigvee\limits_{l \in [1, \lambda]} adj_l(G, v, u)$
                    </p>
                </section>
                <section>
                    <section>
                        <h2>Operaciones etiquetadas</h2>
                        <p style="text-align: left;" class="fragment">
                            Sean $p_1$ y $p_2$ los l&iacute;imtes del &aacute;rea $neigh(v): L[p_1 + 1, p_2]$
                        </p>
                        <p class="fragment">
                            $p_1 = select(B, v) - v, \qquad p_2 = select(B, v + 1) - (v + 1)$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            Definimos como $r_1$ y $r_2$ los l&iacute;mites del &aacute;rea $N_l: N[r_1 + 1, r_2]$
                        </p>
                        <p class="fragment">
                            $r_1 = select(B_L, l) - l, \qquad r_2 = select(B_L, l + 1) - (l + 1)$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            Por &uacute;ltimo, sea $N[r_1 + q_1 + 1, r_1 + q_2]$ el &aacute;rea de $neigh_l(v)$ con:
                        </p>
                        <p class="fragment">
                            $q_1 = rank_l(L, p_1), \qquad q_2 = rank_l(L, p_2)$
                        </p>
                    </section>
                    <section>
                        <h2>Operaciones etiquetadas</h2>
                        <p>
                            $p_1 = select(B, v) - v, \qquad p_2 = select(B, v + 1) - (v + 1)$
                        </p>
                        <p>
                            $r_1 = select(B_L, l) - l, \qquad r_2 = select(B_L, l + 1) - (l + 1)$
                        </p>
                        <p>
                            $q_1 = rank_l(L, p_1), \qquad q_2 = rank_l(L, p_2)$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            $outdegree_l(G, v) = q_2 - q_1$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            $neigh_l(G, v)[j] = N[r_1 + q_1 + j]$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            $indegree_l(G, v) = rank_v(N, r_2) - rank_v(N, r_1)$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            $adj_l(G, v, u)$ ssi $rank_u(N, r_1 + q_2) - rank_u(N, r_1 + q_1) = 1$
                        </p>
                        <p style="text-align: left;" class="fragment">
                            Posici&oacute;n de $rneigh_l(G, v)[j] = select_v(N, rank_v(N, r_1) + j)$
                        </p>
                    </section>
                </section>
                <section>
                    <h2>Grafos agrupados</h2>
                    <p>
                        Diremos que un grafo es un grafo agrupado si es que podemos dividir sus nodos en subsets $V = V_1 \cup V_2 \cup ... \cup V_t$ tal que la mayor&iacute;a de las aristas conecten nodos dentro del mismo subset $V_i$.
                    </p>
                    <svg class="graph_02"></svg>
                </section>
                <section>
                    <h2>$K^2-tree$</h2>
                    <p style="text-align: left;" class="fragment">
                        Divide a la matriz de adyacencia $M[1,n][1,n]$ de un grafo en $k^2$ &aacute;reas iguales de la forma:
                    </p>
                    <p class="fragment">
                        $M[\frac{n}{k}(r-1) + 1, \frac{n}{k}r][\frac{n}{k}(c - 1) + 1, \frac{n}{k}c]$
                    </p>
                    <p style="text-align: left;" class="fragment">
                        Para las filas $1 \leq r \leq k$ y columnas $1 \leq c \leq k$. Esta partici&oacute;n es representada como la ra&iacute;z de un $k^2-ario$ &aacute;rbol cardinal.
                    </p>

                </section>
                <section>
                    <h2>$K^2-tree$</h2>
                    <h4 style="text-align:left;">$adj(G, v, u)$</h4>
                    <pre><code class="hljs" data-noescape data-trim contenteditable>
def adj(G, v, u):
    # Sea T el k<sup>2</sup>-tree de G
    p = root(T)
    s = k<sup>ceil(log<sub>k</sub>n)</sup>
    while s &gt; 1:
        l = s/k
        r = ceil(v/l)
        c = ceil(u/l)
        if not childrenlabeled(T, p, (c - 1)k + r:
            return False
        p = labeledchild(T, p, (c - 1)k + r
        s = l
        v = v - l(r - 1)
        u = u - l(c - 1)
    return True
                    </code></pre>
                </section>

                <section>
                    <h2>$K^2-tree$</h2>
                    <h4 style="text-align:left;">$neigh(G, v)$</h4>
                    <pre><code class="hljs" data-noescape data-trim contenteditable>
def neigh(G, v):
    # Sea T el k<sup>2</sup>-tree de G
    ret = []
    creport(root(T), v, 1, k<sup>ceil(log<sub>k</sub>n)</sup>, ret)
    return ret

def creport(p, r, c<sub>0</sub>, s, ret):
    if s == 1:
        ret.append(c<sub>0</sub>)
    else:
        l = s/k
        r<sub>l</sub> = ceil(r/l)
        r = r - l(r<sub>1</sub>) - 1)
        for c in range(1, k):
            if childrenlabeled(T, p, (c - 1)k + r<sub>l</sub>:
                creport(labeledchild(T, p, (c - 1)k + r<sub>l</sub>),
                        r, c<sub>0</sub> + (c - 1)l, l, ret)

                    </code></pre>
                </section>
                <section>
                    <h2>$K^2-tree$</h2>
                    <h4 style="text-align:left;">$rneigh(G, v)$</h4>
                    <pre><code class="hljs" data-noescape data-trim contenteditable>
def rneigh(G, v):
    # Sea T el k<sup>2</sup>-tree de G
    ret = []
    rreport(root(T), v, 1, k<sup>ceil(log<sub>k</sub>n)</sup>, ret)
    return ret

def rreport(p, c, r<sub>0</sub>, s, ret):
    if s == 1:
        ret.append(r<sub>0</sub>)
    else:
        l = s/k
        c<sub>l</sub> = ceil(c/l)
        c = c - l(c<sub>1</sub>) - 1)
        for r in range(1, k):
            if childrenlabeled(T, p, (c<sub>l</sub> - 1)k + r:
                rreport(labeledchild(T, p, (c<sub>l</sub> - 1)k + r),
                        c, r<sub>0</sub> + (r - 1)l, l, ret)

                    </code></pre>
                </section>
                <section>
                    <h2>Grafos agrupados</h2>
                    <h4 style="text-align:left;">Espacio</h4>
                    <ul style="text-align:left;">
                        <li class="fragment">La representaci&oacute;n de un &aacute;rbol cardinal usando LOUDS sobre un alfabeto de tama&ntilde;o $k^2$ requiere $k^2$ bits por cada nodo en el &aacute;rbol. </li>
                        <li class="fragment">En el peor caso, cada nodo puede inducir un camino de tama&ntilde;o $log_{k^2}n^2$ en el &aacute;rbol.</li>
                        <li class="fragment">Sin embargo el tama&ntilde;o no puede llegar a $ek^2log_{k^2}n^2$ bits, pues los caminos no pueden ser completamente distintos.</li>
                        <li class="fragment">El peor caso es entonces que todos los nodos hasta una profundidad $l + 1$ con $l = \lfloor log_{k^2}e \rfloor$ participen en un camino, y que para cada nodo exista un camino distinto de tama&ntilde;o $h - l$ hacia una hoja, la cantidad m&aacute;xima de nodos con esta propiedad puede ser:</li>
                    </ul>
                    <p class="fragment" >$\frac{(k^2)^{l + 1} - 1}{k^2 - 1} + e(h - l) \lt e(\frac{k^2}{k^2 - 1} + 1 + log_{k^2}\frac{n^2}{e})$</p>
                </section>
                <section>
                    <h2>Grafos agrupados</h2>
                    <h4 style="text-align:left;">Espacio</h4>
                    <ul style="text-align:left;">
                        <li class="fragment">Si representamos B en forma plana, los nodos en caminos distintos de largo $h - l$ utilizan $k^2$ bits cada uno, lo que nos deja con:</li>
                    </ul>
                    <p class="fragment" >$e(\frac{k^2}{k^2 - 1} + k^2(1 + log_{k^2}\frac{n^2}{e})$ bits.</p>
                    <ul style="text-align:left;">
                        <li class="fragment">Usando very sparse bitvectors el espacio se vuelve el n&uacute;mero de nodos multiplicado por $logk^2$. Lo que nos da un espacio de: </li>
                    </ul>
                    <p class="fragment" >$\mathcal{O}(e \cdot log\frac{n^2}{e} + e \cdot logk)$</p>
                </section>
                <section>
                    <h2>Grafos agrupados</h2>
                    <h4 style="text-align:left;">Espacio</h4>
                    <p style="text-align:left;">
                        Sin embargo utilizar very sparse bitvectors tiene un fuerte impacto en la complejidad de las operaciones, pues no son muy veloces resolviendo ranks.
                    </p>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Latex
                math: {
                    mathjax: 'lib/js/MathJax.js',
                    //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
                    config: 'TeX-AMS_HTML-full'
                },



				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/math/math.js', async: true}
				]
			});

        </script>
        <script src="lib/js/d3/d3.min.js"></script>

        <script type="text/javascript">
            // Generates the graphs

            function load_graph(json, force, svg) {
                var color = d3.scale.category20();
                // define arrow markers for graph links
                svg.append('svg:defs').append('svg:marker')
                    .attr('id', 'end-arrow')
                    .attr('viewBox', '-5 -5 10 10')
                    .attr('refX', 6)
                    .attr('markerWidth', 3)
                    .attr('markerHeight', 3)
                    .attr('orient', 'auto')
                    .append('svg:path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#000');

                svg.append('svg:defs')
                    .append('svg:marker')
                    .attr('id', 'start-arrow')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 4)
                    .attr('markerWidth', 3)
                    .attr('markerHeight', 3)
                    .attr('orient', 'auto')
                    .append('svg:path')
                        .attr('d', 'M10,-5L0,0L10,5')
                        .attr('fill', 'red');

                force.nodes(json.nodes)
                    .links(json.links)
                    .start();

                var link = svg.selectAll("line.link")
                    .data(json.links)
                    .enter().append("line")
                    .attr("class", "link")
                    .style("stroke-width", function(d, i) { return Math.sqrt(d.value)})
                    .style('marker-start', function(d, i) { return 'url(#start-arrow)'});

                var node = svg.selectAll("circle.node")
                    .data(json.nodes)
                    .enter().append("circle")
                    .attr("class", "node")
                    .attr("r", 15)
                    .style("fill", function(d, i) { return color(d.group); })
                    .call(force.drag);

                node.append("title")
                    .text(function(d) { return d.name; });


                force.on("tick", function() {
                    link.attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });

                    node.attr("cx", function(d) { return d.x; })
                        .attr("cy", function(d) { return d.y; });

                });
            };
                function generate_svg(name, width, height) {
                    var graph_svg = d3.select(".".concat(name)).attr("width", width).attr("height", height);
                    var force = d3.layout.force()
                                        .charge(-190)
                                        .linkDistance(90)
                                        .linkStrength(1)
                                        .size([width, height]);
                    d3.json(name.concat(".json"), function(json) {
                                load_graph(json, force, graph_svg);});
                }
                generate_svg('graph_02', 500, 500);


        </script>

	</body>
</html>
